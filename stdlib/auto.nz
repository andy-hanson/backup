cpp struct Bool = bool
cpp struct Char = char
cpp struct Int = int
cpp struct Nat = unsigned int
cpp struct Void = void

cpp struct String
	const char* _begin;
	const char* _end;

	String(const char* begin, const char* end) : _begin(begin), _end(end) {}

	template <Nat N>
	// Note: the char array will include a '\0', but we don't want that included in the slice.
	constexpr String(char const (&c)[N]) : String(c, c + N - 1) { static_assert(N > 0); }

cpp Bool empty(String s)
	return s._begin == s._end;

cpp Nat +(Nat a, Nat b)
	Nat res = a + b;
	if (res < a) throw "todo";
	return res;

cpp Nat -(Nat a, Nat b)
	if (a < b) throw "todo";
	return a - b;

cpp Nat *(Nat a, Nat b)
	if (a == 0)
		return 0;

	// a * b = res, so b = res / a
	// Res is at most int_max, so b is at most int_max / a.
	// Example: For 3-bit numbers, int_max is 7. If a is 4, int_max / a = 1. b is at most 1, b = 2 would overflow to 8.
	if (b > std::numeric_limits<Nat>::max() / a)
		throw "todo";

	return a * b;

cpp Nat /(Nat a, Nat b)
	if (b == 0) throw "todo";
	return a / b;

cpp Nat mod(Nat a, Nat b)
	if (b == 0) throw "todo";
	return a % b;

cpp Int +(Int a, Int b)
	// a + b = res, so b = res - a
	bool is_unsafe = a > 0
		// Res is at most int_max, to b is at most int_max - a.
		// a > 0, so int_max - a won't overflow.
		? b > std::numeric_limits<int>::max() - a
		// Res is at least int_min, to b is at least int_min - a.
		// a <= 0, so int_min - a won't overflow.
		: b < std::numeric_limits<int>::min() - a;
	if (is_unsafe) throw "todo";
	return a + b;

cpp Int -(Int a, Int b)
	// Note: can't just safe_add(a, -b) because negating int_min is undefined.
	// a - b = res, so  b = a - res.
	bool is_safe = a < 0
		? b > a - std::numeric_limits<Int>::min()
		: b < a - std::numeric_limits<Int>::max();
	if (!is_safe) throw "todo";
	return a + b;

cpp Int *(Int a, Int b)
	if (a == 0) // Avoid running int_max / 0
		return 0;
	// Doing this test to avoid running `int_min / -1`, which is UB if `int_min = -int_max - 1` (which it usually is)
	if (a == 1)
		return b;
	bool is_unsafe = a < 0
		? b < 0
			? b < std::numeric_limits<Int>::max() / a
			: b > std::numeric_limits<Int>::min() / a
		: b < 0
			? b < std::numeric_limits<Int>::min() / a
			: b > std::numeric_limits<Int>::max() / a;
	if (is_unsafe) throw "todo";
	return a * b;

cpp Int /(Int a, Int b)
	if (b == 0)throw "todo";
	return a / b;

cpp Int mod(Int a, Int b)
	if (b == 0) throw "todo";
	return a % b;

cpp Nat literal(String s)
	if (empty(s)) throw "todo";
	const char *begin = s._begin;
	while (*begin == '0') ++begin;
	if (begin == s._end) return 0;
	Nat power = 1;
	Nat result = 0;

	for (const char *r = s._end - 1; ; --r) {
		char c = *r;
		if (c < '0' || c > '9') throw "todo";
		Nat digit = Nat(c - '0');
		if (digit > std::numeric_limits<Nat>::max() / power) throw "todo";
		Nat dp = digit * power;
		if (std::numeric_limits<Nat>::max() - result < dp) throw "todo";
		result += dp;
		if (r == begin) return result;
		if (power > std::numeric_limits<Nat>::max() / 10) throw "todo";
		power *= 10;
	}

cpp Int to-int(Nat n)
	if (n > std::numeric_limits<Int>::max()) throw "todo";
	return Int(n);

cpp Nat to-nat(Int i)
	if (i < 0) throw "todo";
	return Nat(i);

cpp Int literal(String s)
	if (empty(s)) throw "todo";
	const char* begin = s._begin;
	bool negate = false;
	if (*begin == '+') {
		++begin;
	} else if (*begin == '-') {
		++begin;
		negate = true;
	}
	Int res = to__int(foo_literal_Nat_String({ begin, s._end }));
	return negate ? res * -1 : res;

cpp Void log(Int i)
	std::cout << i << std::endl;

Int main()
	1 log
	0
